<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU 3397 线段树区间合并(巧用lazy标记)]]></title>
    <url>%2F2018%2F12%2F09%2FHDU-3397-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6-%E5%B7%A7%E7%94%A8lazy%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接 题意​ 给出01区间 5种操作 ​ 0就是区间全置0 ，1区间全置1，2 区间反转0-1、1-0 ，3就是求区间有多少个1，4就是求最大连续1的长度 题解我们可以维护0和1的左连续，右连续，最大连续 然后，有多少个1，我们直接维护就可以，就是左右1的和 然后，主要是区间反转 和 区间置01的关系 ，因为传递lazy的时候，他们直接有关系 反转是一个lazy 01，也是一个lazy 首先，我们可以发现，如果你的区间先反转，在置01的时候，我们可以发现，你以前的反转没有用了 因为，我已经覆盖了01，反转没用了 ，所以，我们在置01的时候，把之前的反转lazy清掉 在update的时候，如果是置01，就把lazy01标上，然后吧反转lazy=0 这样我们在处理pushdown，当一个区间有反转和又有区间覆盖的时候，一定是先覆盖了，在区间反转 所以，我们在 pushdown的时候 ，先把覆盖往下穿，因为你先覆盖啊在反转，所以先处理覆盖 在传覆盖的时候，同时再把反转标记清空 然后在处理反转，传递反转的时候，如果子区间有覆盖了，那么就是父区间刚才传递下去的覆盖 所以这个时候，直接把覆盖反转一下就可以了，否则，我们把反转lazy，反转一下就可以了 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 100005struct node&#123; int l,r; int ls,rs,sum; int lazy; int ls2,rs2,sum2; int lazy01; int num;&#125;;node shu[N&lt;&lt;2];int a[N];void pushup(int rt)&#123; shu[rt].ls = shu[rt&lt;&lt;1].ls; shu[rt].rs = shu[rt&lt;&lt;1|1].rs; if(shu[rt&lt;&lt;1].ls==(shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l + 1)) &#123; shu[rt].ls += shu[rt&lt;&lt;1|1].ls; &#125; if(shu[rt&lt;&lt;1|1].rs==(shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l + 1)) &#123; shu[rt].rs += shu[rt&lt;&lt;1].rs; &#125; shu[rt].sum = max(max(shu[rt&lt;&lt;1].sum,shu[rt&lt;&lt;1|1].sum), shu[rt&lt;&lt;1].rs+shu[rt&lt;&lt;1|1].ls); shu[rt].ls2 = shu[rt&lt;&lt;1].ls2; shu[rt].rs2 = shu[rt&lt;&lt;1|1].rs2; if(shu[rt&lt;&lt;1].ls2==(shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l + 1)) &#123; shu[rt].ls2 += shu[rt&lt;&lt;1|1].ls2; &#125; if(shu[rt&lt;&lt;1|1].rs2==(shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l + 1)) &#123; shu[rt].rs2 += shu[rt&lt;&lt;1].rs2; &#125; shu[rt].sum2 = max(max(shu[rt&lt;&lt;1].sum2,shu[rt&lt;&lt;1|1].sum2), shu[rt&lt;&lt;1].rs2+shu[rt&lt;&lt;1|1].ls2); shu[rt].num = shu[rt&lt;&lt;1].num+shu[rt&lt;&lt;1|1].num;&#125;void build(int rt,int l,int r)&#123; shu[rt].l = l,shu[rt].r = r; shu[rt].lazy = 0; shu[rt].lazy01 = -1; if(l==r) &#123; if(a[l]) &#123; shu[rt].ls = shu[rt].rs = shu[rt].sum = 1; shu[rt].ls2 = shu[rt].rs2 = shu[rt].sum2 = 0; shu[rt].num = 1; &#125; else &#123; shu[rt].ls = shu[rt].rs = shu[rt].sum = 0; shu[rt].ls2 = shu[rt].rs2 = shu[rt].sum2 = 1; shu[rt].num = 0 ; &#125; return; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid); build(rt&lt;&lt;1|1,mid+1,r); pushup(rt);&#125;void pushdown(int rt)&#123; int v = shu[rt].lazy01; int len1 = shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l +1; int len2 = shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l +1; if(v != -1) &#123; shu[rt&lt;&lt;1].ls = shu[rt&lt;&lt;1].rs = shu[rt&lt;&lt;1].sum = shu[rt&lt;&lt;1].num = (v?len1:0); shu[rt&lt;&lt;1].ls2 = shu[rt&lt;&lt;1].rs2 = shu[rt&lt;&lt;1].sum2 = (v?0:len1); shu[rt&lt;&lt;1|1].ls = shu[rt&lt;&lt;1|1].rs = shu[rt&lt;&lt;1|1].sum = shu[rt&lt;&lt;1|1].num = (v?len2:0); shu[rt&lt;&lt;1|1].ls2 = shu[rt&lt;&lt;1|1].rs2 = shu[rt&lt;&lt;1|1].sum2 = (v?0:len2); shu[rt&lt;&lt;1].lazy = shu[rt&lt;&lt;1|1].lazy = 0 ; //注销子区间的反转 因为有覆盖了 shu[rt&lt;&lt;1].lazy01 = shu[rt&lt;&lt;1|1].lazy01 = v ; shu[rt].lazy01 = -1; &#125; if(shu[rt].lazy) &#123; if(shu[rt&lt;&lt;1].lazy01&gt;=0) //覆盖反转覆盖 因为有覆盖不用看反转 &#123; shu[rt&lt;&lt;1].lazy01 = 1 - shu[rt&lt;&lt;1].lazy01; &#125; else shu[rt&lt;&lt;1].lazy ^= 1; //否则反转反转标记 if(shu[rt&lt;&lt;1|1].lazy01&gt;=0) &#123; shu[rt&lt;&lt;1|1].lazy01 = 1 - shu[rt&lt;&lt;1|1].lazy01; &#125; else shu[rt&lt;&lt;1|1].lazy ^= 1; shu[rt&lt;&lt;1].num = len1 - shu[rt&lt;&lt;1].num; shu[rt&lt;&lt;1|1].num = len2 - shu[rt&lt;&lt;1|1].num; swap(shu[rt&lt;&lt;1].ls,shu[rt&lt;&lt;1].ls2); swap(shu[rt&lt;&lt;1].rs,shu[rt&lt;&lt;1].rs2); swap(shu[rt&lt;&lt;1].sum,shu[rt&lt;&lt;1].sum2); swap(shu[rt&lt;&lt;1|1].ls,shu[rt&lt;&lt;1|1].ls2); swap(shu[rt&lt;&lt;1|1].rs,shu[rt&lt;&lt;1|1].rs2); swap(shu[rt&lt;&lt;1|1].sum,shu[rt&lt;&lt;1|1].sum2); shu[rt].lazy = 0; &#125;&#125;int Find(int rt,int l,int r)&#123; int L = shu[rt].l, R = shu[rt].r; if(L==l&amp;&amp;R==r) &#123; return shu[rt].sum; &#125; pushdown(rt); int ans = 0; int mid = (L+R)&gt;&gt;1; if(r&lt;=mid) &#123; ans = Find(rt&lt;&lt;1,l,r); &#125; else if(l&gt;mid) &#123; ans = Find(rt&lt;&lt;1|1,l,r); &#125; else &#123; int v1 = Find(rt&lt;&lt;1,l,mid); int v2 = Find(rt&lt;&lt;1|1,mid+1,r); int v3 = min(shu[rt&lt;&lt;1].rs, mid-l+1) + min(shu[rt&lt;&lt;1|1].ls,r-mid-1+1); int v4 = max(v1,v2); ans = max(v3,v4); &#125; pushup(rt); return ans;&#125;int query(int rt,int l,int r)&#123; int L = shu[rt].l, R = shu[rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; return shu[rt].num; &#125; else &#123; pushdown(rt); int ans = 0; int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) ans+=query(rt&lt;&lt;1,l,r); if(r&gt;mid) ans+= query(rt&lt;&lt;1|1,l,r); pushup(rt); return ans; &#125;&#125;void update01(int rt,int l,int r,int val)&#123; int L = shu[rt].l, R = shu[rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; if(val == 2) &#123; swap(shu[rt].ls,shu[rt].ls2); swap(shu[rt].rs,shu[rt].rs2); swap(shu[rt].sum,shu[rt].sum2); shu[rt].num = (R-L+1) - shu[rt].num; shu[rt].lazy ^=1; &#125; else &#123; int k = R-L+1; shu[rt].ls = shu[rt].rs = shu[rt].sum = shu[rt].num = (val?k:0); shu[rt].ls2 = shu[rt].rs2 = shu[rt].sum2 =(val?0:k); shu[rt].lazy01 = val; shu[rt].lazy = 0; &#125; &#125; else &#123; pushdown(rt); int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) update01(rt&lt;&lt;1,l,r,val); if(mid&lt;r) update01(rt&lt;&lt;1|1,l,r,val); pushup(rt); &#125;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); memset(shu,0,sizeof(shu)); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); &#125; build(1,1,n); while(m--) &#123; int x,l,r; scanf("%d%d%d",&amp;x,&amp;l,&amp;r); l++,r++; if(x&lt;=2) &#123; update01(1,l,r,x); &#125; else if(x==3) &#123; printf("%d\n",query(1,l,r)); &#125; else if(x==4) &#123; printf("%d\n",Find(1,l,r)); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ACM-ICPC 亚洲区域赛 北京站 A]]></title>
    <url>%2F2018%2F12%2F07%2F2018-ACM-ICPC-%E4%BA%9A%E6%B4%B2%E5%8C%BA%E5%9F%9F%E8%B5%9B-%E5%8C%97%E4%BA%AC%E7%AB%99-A%2F</url>
    <content type="text"><![CDATA[Jin Yong’s Wukong Ranking List时间限制:1000ms 单点时限:1000ms 内存限制:512MB 描述Jin Yong was the most famous and popular Chinese wuxia (The one who fight bad people by his Wukong i.e. Wushu and Kongfu) novelist who lived in Hong Kong. Between 1955 and 1972, he wrote 14 novels which earned him a reputation as one of the greatest and most popular Chinese writers. Over 100 million copies of his works have been sold worldwide，not including a countless number of pirated copies. Jin Yong’s works seem to have magic. Once you begin to read a novel of his, you just can’t stop until you finish it. Last month, Jin Yong passed away at the age of 94. Many Jin Yong’s fans in PKU held a meeting to memorize him. Jin Yong’s fans always like to discuss or argue or even quarrel about whose Wukong are better among the wuxia characters of his novel. During the meeting, this happened again: Every fans said some words like “Qiao Feng’s Wukong is better than Guo Jing’s”. Obviously, those words may contradict each other and then cause quarrels. As a boring and girlfriendless male programmer of EECS school, you always want to make some things. So you are eager to point out the contradictions as soon as possible. That means, you want to find out the first one whose words contradict the words said by others before him. Please note that if A is better than B, and B is better than C, then of course A must be better than C. 输入There are no more than 15 test cases. For each test case: The first line is an integer n( 1 &lt;= n &lt;=20), meaning that there are n sentences. The following n lines are those n sentences which is in the format below: s1 s2 This means someone said that s1’s Wukong was better than s2’s. Both s1 and s2 are names of Jin Yong’s characters which consists of only English letters. It’s guaranteed that s1 and s2 are different, and their length is no more than 30. Names are case sensitive. 输出For each test case, print the first sentence which cause a contradiction. If there are no contradiction, print 0 instead. 提示DON’T try to figure out who are those names in the sample and waste your time. 样例输入 123456789102BrokenReputation ExtinctNunHelloLaught EnvelopeNotFlat6LandOverWind LonelyLightFireMonk CutTheForestCutTheForest LookCrazyMakeFoxRush LetMeGoHeroAunt UniqueLandLookCrazy FireMonk 样例输出 120LookCrazy FireMonk 题意​ 给你人名 代表前者比后者强 求第一个出现错误的地方 人物强弱满足传递性，A &gt; B，B &gt; C，A &gt; C 题解​ 签到题，直接 map 映射一下hash 你会发现永远是小的数字比大的数字厉害，所以，当出现大的数字比小的数字厉害的时候就是第一个错误点，太水了，我还在想什么拓扑排序啥的，懵了半天，哈哈 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt;m1;int main()&#123; int n; while(cin&gt;&gt;n) &#123; m1.clear(); int tot = 1; int flag = 0; string ans1 ,ans2; for(int i=0;i&lt;n;i++) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; if(!m1[s1]) m1[s1] = tot++; if(!m1[s2]) m1[s2] = tot++; if(m1[s1]&gt;=m1[s2]&amp;&amp;flag==0) &#123; flag = 1; ans1 = s1; ans2 = s2; &#125; &#125; if(!flag) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;ans1&lt;&lt;" "&lt;&lt;ans2&lt;&lt;endl; &#125;&#125;#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt;m1;int main()&#123; int n; while(cin&gt;&gt;n) &#123; m1.clear(); int tot = 1; int flag = 0; string ans1 ,ans2; for(int i=0;i&lt;n;i++) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; if(!m1[s1]) m1[s1] = tot++; if(!m1[s2]) m1[s2] = tot++; if(m1[s1]&gt;=m1[s2]&amp;&amp;flag==0) &#123; flag = 1; ans1 = s1; ans2 = s2; &#125; &#125; if(!flag) cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;ans1&lt;&lt;" "&lt;&lt;ans2&lt;&lt;endl; &#125;&#125; ps ： ​ 这个真的得说在现场系列了，当时把题看完队友老哥直接上去就AC了。过两天有时间的写个退役总结]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #525 (Div. 2) C]]></title>
    <url>%2F2018%2F12%2F07%2FCodeforces-Round-525-Div-2-C%2F</url>
    <content type="text"><![CDATA[题目链接 Examples Input 1231 2 3 Output 10 Input 1237 6 3 Output 12321 1 12 2 4 Note In the first sample, the array is already increasing so we don’t need any operations. In the second sample: In the first step: the array becomes [8,6,3] In the second step: the array becomes [0,2,3] 题意​ 给定一段序列，序列的大小是n，n最大2000，然后有两种操作，第一种是从1到第i位，区间加上一个数x 第二种操作，是区间1到第i为，区间取模一个数x，然后现在问你，对于给定的序列，能不能在n+1次操作后， 使得这个序列是严格递增的，如果可以输出操作数和每次操作的情况， 输出格式，1 x y ，2 x y ，1代表是加操作，2代表是取模，x代表1-x位操作，y代表数值 题解​ 一开始想傻了还以为是每个点随便加呢，哈哈，我们可以这样想，题目已经给出暗示了，n+1次操作嘛， 那肯定是加了n次，最后一次取模得到结果呗，因为你不可能多次取模吧，那样太复杂了，我们要学着简化题目， 根据题目的信息，对题目化简，然后怎么处理呢，一开始我是正向的去想的，很麻烦，因为前面的数值会对后面的 造成影响，所以啊，我们从后往前考虑呗，先把最后一个数处理了，然后一直到第一个就行呗，中间记录一下过程 对于第i位，影响的是1-i-1 对吧，所以从后往前的时候维护一个sum 一直记录过去就行，然后最关键的是那个一次取模是什么样的呢 我们可以发现假如说我构造出的序列，最标准的是什么情况，从0 - n-1 吧 一定是严格递增的 所以我们可以考虑对n取模，然后其他的数都根据他来构造，每次看和n取模的关系，然后就可以了 AC代码123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define ll long long#define N 2005using namespace std;ll a[N];int main()&#123; ll n; while(scanf("%lld",&amp;n)==1) &#123; for(ll i=0;i&lt;n;i++) &#123; scanf("%lld",&amp;a[i]); &#125; printf("%lld\n",n+1); ll sum = 0; for(ll i=n-1;i&gt;=0;i--) &#123; ll x1 = i-((a[i]+sum)%n); if(x1&lt;0) &#123; x1+=n; &#125; sum+=x1; printf("1 %lld %lld\n",i+1,x1); &#125; printf("2 %lld %lld\n",n,n); &#125;&#125; ps： ​ 要学会简化题目啊，根据题中信息来往上靠，对做题很有帮助啊！切记，切记！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4348 主席树区间更新在线]]></title>
    <url>%2F2018%2F12%2F06%2FHDU-4348-%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0%E5%9C%A8%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目链接 题意​ 给定区间 q查询l r c l r 更新加d 然后带一个时间戳 加1 然后 h 询问l到r 在t时间戳 b 把时间戳改为t 题意​ 标准在线主席树啊，树上维护的不是权值线段树，而是对应的正常的树然后，怎么处理区间更新呢 ，我们都知道，主席树是根据之前的树，来对之前的结点复用也好 总之相当于多一颗树，我们单点修改的好说，只是影响一条链，但是区间更新怎么办 我们可以想到打标记 lazy，但是我们怎么，更新的时候怎么pushup 呢，这个好处理 我们可以发现 我们树从上往下的结构嘛，所以在递归的时候，可以把这个父节点的sum，直接更新 这样省去了pushup 其实也差不多，主要是 怎么处理pushdown 因为你没办法往下传lazy， 这样就会多开结点，相当于你多开了区间这么多结点，直接mle啊 空间爆炸，所以我们要考虑 不pushdown，我们可以从上往下，对树遍历的时候，找完全是你要找的区间 并且在树上有的，就是递归的时候 写三个的那种， 完全是左边r&lt;=mid 就在递归左，完全是右 l&gt;mid 就递归右 然后，中间区间的话，在拆开递归，l到mid，mid+1到r 这样，更新的时候，判断l\==L，r==R，这样保证你更新的区间，一定是你要找的区间 然后对应的，我们在更新的时候，sum已经更新完了，加上你更新的值和对区间的影响长度， 即R-L+1，然后，我们呢把完全要找的区间打一个lazy 然后，在查询的时候，我们从上往下的时候，把所有要找的区间lazy算一下，加上去， 这样保证一定是对的， 举个例子 比如 1-10 我更新 1-7 那么 树上影响的区间 1-10 1-5，6-10 6-8 6-7 这几个区间吧，我们在从上往下递归的时候，已经把他们的和都更新过了 然后，我们对于1-5，6-7 这几个区间打了lazy 然后当我们查询的时候，假如找1-4 因为和已经更新过了，所以 1-3的和直接返回就可以 然后找到4-5的时候，接下来递归4，这个时候 正常的操作是 pushdown 标记下传 ，但是我们可以不传标记， 直接把标记的值乘上要找的区间长度 ，加上就可以了 因为你是三个判断的那种递归，保证你找的区间一定是对应要找的长度，所以这样写没有问题 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100000 + 5;#define ll long longll a[N] ;int rt[N * 35], ls[N * 35], rs[N * 35];ll lazy[N*35];ll sum [N * 35];int tot;void Build(int &amp;o, int l, int r)&#123; o = ++ tot; sum[o] = a[l]; lazy[o] = 0; if(l == r) return; int m = (l + r) &gt;&gt; 1; Build(ls[o], l, m); Build(rs[o], m + 1, r); sum[o] = sum[ls[o]] + sum[rs[o]];&#125;void update(int &amp;o, int l, int r, int last, int L, int R, ll val)&#123; o = ++ tot; ls[o] = ls[last]; rs[o] = rs[last]; lazy[o] = lazy[last]; sum[o] = sum[last]+val*(R-L+1); //把每个区间的增量都算上 这一步省去了pushup if(L==l&amp;&amp;r==R) &#123; lazy[o] += val; //完全是要找区间的并且是完整的一个区间的更新lazy return ; &#125; int m = (l + r) &gt;&gt; 1; if(R&lt;=m) update(ls[o],l,m,ls[last],L,R,val); else if(L&gt;m) update(rs[o],m+1,r,rs[last],L,R,val); else &#123; update(ls[o],l,m,ls[last],L,m,val); update(rs[o],m+1,r,rs[last],m+1,R,val); &#125;&#125;ll query(int ss, int l, int r, int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; return sum[ss]; &#125; ll ans = lazy[ss]*(R-L+1); // 每次往下找的时候 把这个区间的lazy对最后和的影响算一下 这一步省去了pushdown int m = (l + r) &gt;&gt; 1; if(R&lt;=m) ans+=query(ls[ss],l,m,L,R); else if(L&gt;m) ans+=query(rs[ss],m+1,r,L,R); else &#123; ans+=query(ls[ss],l,m,L,m); ans+=query(rs[ss],m+1,r,m+1,R); &#125; return ans;&#125;int main()&#123; int n,q; while(scanf("%d%d", &amp;n, &amp;q)==2) &#123; for(int i = 1; i &lt;= n; i ++) &#123; scanf("%lld",&amp;a[i]); &#125; tot = 0; int sz = n; Build(rt[0],1, sz); int time = 0 ; char s[15]; int ql,qr; while(q--) &#123; scanf("%s",s); if(s[0]=='Q') &#123; scanf("%d%d", &amp;ql, &amp;qr); printf("%lld\n",query(rt[time],1,sz,ql,qr)); &#125; else if(s[0]=='C') &#123; ll val; scanf("%d%d%lld", &amp;ql, &amp;qr,&amp;val); update(rt[time+1],1,sz,rt[time],ql,qr,val); time++; &#125; else if(s[0]=='H') &#123; int time1; scanf("%d%d%d", &amp;ql, &amp;qr,&amp;time1); printf("%lld\n",query(rt[time1],1,sz,ql,qr)); &#125; else if(s[0]=='B') &#123; scanf("%d",&amp;time); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3911 线段树区间合并 延迟标记]]></title>
    <url>%2F2018%2F12%2F06%2FHDU-3911-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6-%E5%BB%B6%E8%BF%9F%E6%A0%87%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[题目链接 题意​ 给定区间01，然后可以把区间0变1，1变0，然后求最大连续1的长度 题解正常的维护01区间，用lazy 来表示反转，多维护一个最大0的左连续，右连续，连续最大 然后反转的时候，直接swap 一下就可以 但是有一个坑点，就是查找区间最大连续1的时候，如果是包含你要的区间 那就直接返回这个区间最大的值，如果是这个区间完全左边和右边的时候也直接递归就可以 但是当在这个区间某一部分的时候，会有问题 比如 1-10 你找 2-8 你肯定要找到 1-5 和 6-10 对吧 但是，你分开区间的时候，你会把 1-5和6-10 区间连续的部分分开 所以，一定要考虑中间分开的连续区间 第一种就是完全包含直接返回，第二种完全右边和左边直接递归 第三种中间某部分分开的，比如 1-10，你找 2-8，1-10肯定没有了， 你要找1-5 和 6-10 里面的对吧，但是你分开的时候 1-5的右区间和6-10左区间连续被分开了 所以你要讨论一下 而且还要注意大小 因为 假设 1-10 找2-8 假设1-5 右连续贯穿 这个时候就比2大了 同理右儿子左连续也得比较一下 具体的看代码就行，主要来说就是你在往下递归这个树的时候，在分开的时候多考虑一下中间的情况 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 100005struct node&#123; int l,r; int ls,rs,sum; int lazy; int ls2,rs2,sum2;&#125;;node shu[N&lt;&lt;2];int a[N];void pushup(int rt)&#123; shu[rt].ls = shu[rt&lt;&lt;1].ls; shu[rt].rs = shu[rt&lt;&lt;1|1].rs; if(shu[rt&lt;&lt;1].ls==(shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l + 1)) &#123; shu[rt].ls += shu[rt&lt;&lt;1|1].ls; &#125; if(shu[rt&lt;&lt;1|1].rs==(shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l + 1)) &#123; shu[rt].rs += shu[rt&lt;&lt;1].rs; &#125; shu[rt].sum = max(max(shu[rt&lt;&lt;1].sum,shu[rt&lt;&lt;1|1].sum),shu[rt&lt;&lt;1].rs+shu[rt&lt;&lt;1|1].ls); shu[rt].ls2 = shu[rt&lt;&lt;1].ls2; shu[rt].rs2 = shu[rt&lt;&lt;1|1].rs2; if(shu[rt&lt;&lt;1].ls2==(shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l + 1)) &#123; shu[rt].ls2 += shu[rt&lt;&lt;1|1].ls2; &#125; if(shu[rt&lt;&lt;1|1].rs2==(shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l + 1)) &#123; shu[rt].rs2 += shu[rt&lt;&lt;1].rs2; &#125; shu[rt].sum2 = max(max(shu[rt&lt;&lt;1].sum2,shu[rt&lt;&lt;1|1].sum2),shu[rt&lt;&lt;1].rs2+shu[rt&lt;&lt;1|1].ls2);&#125;void build(int rt,int l,int r)&#123; shu[rt].l = l,shu[rt].r = r; shu[rt].lazy = 0; if(l==r) &#123; if(a[l]) &#123; shu[rt].ls = shu[rt].rs = shu[rt].sum = 1; shu[rt].ls2 = shu[rt].rs2 = shu[rt].sum2 = 0; &#125; else &#123; shu[rt].ls = shu[rt].rs = shu[rt].sum = 0; shu[rt].ls2 = shu[rt].rs2 = shu[rt].sum2 = 1; &#125; return; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid); build(rt&lt;&lt;1|1,mid+1,r); pushup(rt);&#125;void pushdown(int rt)&#123; if(shu[rt].lazy) &#123; swap(shu[rt&lt;&lt;1].ls,shu[rt&lt;&lt;1].ls2); swap(shu[rt&lt;&lt;1].rs,shu[rt&lt;&lt;1].rs2); swap(shu[rt&lt;&lt;1].sum,shu[rt&lt;&lt;1].sum2); swap(shu[rt&lt;&lt;1|1].ls,shu[rt&lt;&lt;1|1].ls2); swap(shu[rt&lt;&lt;1|1].rs,shu[rt&lt;&lt;1|1].rs2); swap(shu[rt&lt;&lt;1|1].sum,shu[rt&lt;&lt;1|1].sum2); shu[rt&lt;&lt;1].lazy ^= shu[rt].lazy; shu[rt&lt;&lt;1|1].lazy ^= shu[rt].lazy; shu[rt].lazy ^= 1; &#125;&#125;void update(int rt,int l,int r)&#123; int L = shu[rt].l , R = shu[rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; swap(shu[rt].ls,shu[rt].ls2); swap(shu[rt].rs,shu[rt].rs2); swap(shu[rt].sum,shu[rt].sum2); shu[rt].lazy ^=1; &#125; else &#123; pushdown(rt); int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) update(rt&lt;&lt;1,l,r); if(mid&lt;r) update(rt&lt;&lt;1|1,l,r); pushup(rt); &#125;&#125;int Find(int rt,int l,int r)&#123; int L = shu[rt].l, R = shu[rt].r; if(L==l&amp;&amp;R==r) &#123; return shu[rt].sum; &#125; pushdown(rt); int ans = 0; int mid = (L+R)&gt;&gt;1; if(r&lt;=mid) &#123; ans = Find(rt&lt;&lt;1,l,r); &#125; else if(l&gt;mid) &#123; ans = Find(rt&lt;&lt;1|1,l,r); &#125; else &#123; int v1 = Find(rt&lt;&lt;1,l,mid); int v2 = Find(rt&lt;&lt;1|1,mid+1,r); int v3 = min(shu[rt&lt;&lt;1].rs, mid-l+1) + min(shu[rt&lt;&lt;1|1].ls,r-mid-1+1); int v4 = max(v1,v2); ans = max(v3,v4); &#125; pushup(rt); return ans;&#125;int main()&#123; int n; while(scanf("%d",&amp;n)==1) &#123; memset(shu,0,sizeof(shu)); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; build(1,1,n); int m; scanf("%d",&amp;m); while(m--) &#123; int x,l,r; scanf("%d%d%d",&amp;x,&amp;l,&amp;r); if(x==0) &#123; printf("%d\n",Find(1,l,r)); &#125; else if(x==1) &#123; update(1,l,r); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java1]]></title>
    <url>%2F2018%2F12%2F04%2Fjava1%2F</url>
    <content type="text"><![CDATA[Jdk包含jre ，jre包含jvm虚拟机 Jdk (java 开发包) &gt; jre (java运行环境) &gt; jvm (java 虚拟机) 有多少个类就会产生多少个 class 文件，public class 必须和文件名一致 注释不能嵌套 标识符​ 给我们类和方法变量起名，命名 以_ $ 字母开头，其他地方，数字 _ $ 字母，不能为关键字 字符集和编码​ Unicode，两个字节一个字符，一字节八位 2的八次方，256个状态 两个字节 2的16，65536个字符，(汉字 两万个) 可以表示所有的 编码和解码要一致，一般都是 gbk和unicode 发生冲突 Utf-8 既有一个又有两个字节 变量和变量类型，转换​ ​ 引用类型四个字节：数组，对象，借口 ​ 一字节八位 二进制int 0b，八进制 int 0开头，16进制 0x ，Intger.toBinaryString(int xx) 转换成二进制字符串 八进制. toOctalString，16进制 toHexString 直接给变量赋予数值的时候，如果数据大小没有超过byte short char 的表述的范围可已自动转换 默认是int，如果给long的时候，在数字的后面加上l L，大小写都行，否则或报错，但是正常键盘输入 浮点数默认是 double的，所以直接将浮点数给float 会有报错 ，在数字后面加上f/F Int 四个字节 完全表示范围的所有数 Float 也是四个字节 但是不是精确的表示所有小数 浮点数有误差比较的时候 最好用 Bigdecimal 大数类 BigInteger Char 用的是 Unicode 表示的 用反斜杠\ 转义字符 ‘ ” \ 这个几个需要转义字符 Char 运算是直接当作整数计算 a 对应 97 Boolean 只占一位 而不是一个字节 自动转换类型，容量小可以自动转为大的类型 在范围内强制转换可以用，超过范围 可以运行但是转换成无意义的值 Final常量最好用大写来写，中间用下划线分开 小数也可以取余数！ &amp; 有0为0 | 有1为1 ~ 全取反 ^ 不一样为1 一样为0 三目运算符（布尔表达式）? A : B switchSwitch 里面可以放置 int 或者可以自动转换为int的类型 byte char short 枚举和String 多值选择的时候，我们选用switch 1234567switch（xx）&#123; case “字符串”：//也可以上述那几种 break; default: // 上述都不满足的时候 break;&#125; 在语句里面，分支里面不放break，就会也加入判断里面，就是说你判断成功 但是不跳过，接着下次的判断了 执行顺序：执行case，直到break为止，如果有default，也执行无论顺序 带标签的break 和 continue Outer: 后面放循环语句 Continue outer 这时候就从这跳到标签那的语句]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈尔滨理工大学软件与微电子学院院赛高年级组A]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%93%88%E5%B0%94%E6%BB%A8%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E4%B8%8E%E5%BE%AE%E7%94%B5%E5%AD%90%E5%AD%A6%E9%99%A2%E9%99%A2%E8%B5%9B%E9%AB%98%E5%B9%B4%E7%BA%A7%E7%BB%84A%2F</url>
    <content type="text"><![CDATA[题目链接 12345来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld 题目描述 ​ 小乐乐得知一周有7天之后就对7产生了兴趣。 ​ 小乐乐得到了两堆数字数字时连续的。 ​ 第一堆包含[1,n]n个数字，第二堆包含[1,m]m个数字。 ​ 小乐乐想要从两堆中各挑选出一个整数x,y，使得x,y的和为7的倍数。 请问小乐乐有多少种组合的方式。 输入描述:1输入整数n,m。(1&lt;=n,m&lt;=1e6) 输出描述:1输出满足的对数。 示例1 输入复制 16 7 输出复制 16 说明1(1,6),(2,5),(3,4),(4,3),(5,2),(6,1) 题解 ​ 一开始智障了，考虑７的倍数之间的关系，然后暴力打了个表，断断续续的看了半天， 也没检查有没有错误，结果表打错了，还推了半天直接gg，最后才想明白怎么处理， 举个例子，我们要是暴力的处理就是 n^2 的 第一层枚举i，第二层枚j，然后 (i+j)%7==0 对吧，然后我们在去像怎么优化，举个例子 比如 1 29 里面有 1 6 ，1 13，1 20，1 27 我们可以写一下数学公式，设x，7*x - i &lt;= m 我们可以得到这个公式，里面x代表的是 7的几倍也就是几组7的倍数，要想x得到的最大 就取等于呗，化简公式：x = (m+i)/7; 然后只需要遍历一遍1-min(n,m)，枚举i就可以了，然后还有一个注意点就是公式要变成 x = (m+i)/7 - i/7 ; 举个例子 25 26 i = 7的时候 x 按照之前的结果是 4 但是实际只有 3个 因为你把 i/7 的情况多算了 就相当于多了一个 0 7 所以 要减去i自身的情况 代码1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)==2) &#123; ll sum = 0; int minx = min(n,m); int maxn = max(n,m); for(int i=1;i&lt;=minx;i++) &#123; sum+=((maxn+i)/7-i/7); //printf("%d %d\n",i,((maxn+i)/7-i/7)); &#125; printf("%lld\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4553 线段树区间合并]]></title>
    <url>%2F2018%2F11%2F30%2FHDU-4553-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目链接 题意：​ 有女神和屌丝两种朋友，屌丝每次申请x时间，女神每次也申请x时间，每次都找最靠左的时间 然后女神优先级高于屌丝，可以覆盖屌丝的时间，但是，如果屌丝被覆盖的不完全，比如 1-5 是屌丝 然后女神占了1-3，剩下的4-5 还是屌丝的。 题解：​ 正常的线段树区间01维护，然后开两个树，一个维护屌丝的时间，一个维护女神的时间 屌丝就正常在屌丝的树上，维护 更新 ，然后女神的话，现在屌丝树上看 有没有地方 有地方就 更新屌丝树，然后如果没有地方的话 ，在女神树上找一段时间 找到了 在女神树和屌丝树都更新 一下因为有可能女神占用屌丝的时间 ，比之前的屌丝时间还多，所以需要更新一下。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 100010struct node&#123; int l,r; int ls,rs,sum; int lazy;&#125;;node shu[2][N&lt;&lt;2];void pushup(int rt,int inx)&#123; shu[inx][rt].ls = shu[inx][rt&lt;&lt;1].ls; shu[inx][rt].rs = shu[inx][rt&lt;&lt;1|1].rs; if(shu[inx][rt&lt;&lt;1].ls==(shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].l + 1)) &#123; shu[inx][rt].ls += shu[inx][rt&lt;&lt;1|1].ls; &#125; if(shu[inx][rt&lt;&lt;1|1].rs==(shu[inx][rt&lt;&lt;1|1].r - shu[inx][rt&lt;&lt;1|1].l + 1)) &#123; shu[inx][rt].rs += shu[inx][rt&lt;&lt;1].rs; &#125; shu[inx][rt].sum = max(max(shu[inx][rt&lt;&lt;1].sum,shu[inx][rt&lt;&lt;1|1].sum),shu[inx][rt&lt;&lt;1].rs+shu[inx][rt&lt;&lt;1|1].ls);&#125;void pushdown(int rt,int inx)&#123; if(shu[inx][rt].lazy == 1) &#123; shu[inx][rt&lt;&lt;1].ls = shu[inx][rt&lt;&lt;1].rs = shu[inx][rt&lt;&lt;1].sum = (shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].l + 1); shu[inx][rt&lt;&lt;1|1].ls = shu[inx][rt&lt;&lt;1|1].rs = shu[inx][rt&lt;&lt;1|1].sum = (shu[inx][rt&lt;&lt;1|1].r - shu[inx][rt&lt;&lt;1|1].l + 1); shu[inx][rt&lt;&lt;1].lazy = shu[inx][rt].lazy; shu[inx][rt&lt;&lt;1|1].lazy = shu[inx][rt].lazy; shu[inx][rt].lazy = 0; &#125; else if(shu[inx][rt].lazy == 2) &#123; shu[inx][rt&lt;&lt;1].ls = shu[inx][rt&lt;&lt;1].rs = shu[inx][rt&lt;&lt;1].sum = 0; shu[inx][rt&lt;&lt;1|1].ls = shu[inx][rt&lt;&lt;1|1].rs = shu[inx][rt&lt;&lt;1|1].sum = 0; shu[inx][rt&lt;&lt;1].lazy = shu[inx][rt].lazy; shu[inx][rt&lt;&lt;1|1].lazy = shu[inx][rt].lazy; shu[inx][rt].lazy = 0; &#125;&#125;void build(int rt,int l,int r,int inx)&#123; shu[inx][rt].l = l,shu[inx][rt].r = r; shu[inx][rt].lazy = 0; if(l==r) &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = 1; return; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid,inx); build(rt&lt;&lt;1|1,mid+1,r,inx); pushup(rt,inx);&#125;void update(int rt,int l,int r,int val,int inx)&#123; int L = shu[inx][rt].l , R = shu[inx][rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; if(val) &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = R-L+1; shu[inx][rt].lazy = 1; &#125; else &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = 0; shu[inx][rt].lazy = 2; &#125; &#125; else &#123; pushdown(rt,inx); int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) update(rt&lt;&lt;1,l,r,val,inx); if(mid&lt;r) update(rt&lt;&lt;1|1,l,r,val,inx); pushup(rt,inx); &#125;&#125;int Find(int rt,int val,int inx)&#123; if(shu[inx][rt].ls == val) return shu[inx][rt].l; //当前区间最左边可以吗 if(shu[inx][rt].sum&gt;=val) //当前区间可以吗 &#123; pushdown(rt,inx); //下传 if(shu[inx][rt&lt;&lt;1].sum&gt;=val) return Find(rt&lt;&lt;1,val,inx); //当前区间左儿子可以吗 if(shu[inx][rt&lt;&lt;1].rs+shu[inx][rt&lt;&lt;1|1].ls &gt;=val) return shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].rs+1; // 当前区间分开的中间可以吗 if(shu[inx][rt&lt;&lt;1|1].sum&gt;=val) return Find(rt&lt;&lt;1|1,val,inx); // 当前区间右儿子可以吗 &#125; return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); int kk = 1; while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); memset(shu,0,sizeof(shu)); build(1,1,n,0); // 0代表ds树 build(1,1,n,1); // 1代表ns树 printf("Case %d:\n",kk++); char s1[10]; for(int i=0; i&lt;m; i++) &#123; scanf("%s",s1); if(s1[0]=='D') &#123; int x; scanf("%d",&amp;x); int ans = Find(1,x,0); if(ans == 0 ) printf("fly with yourself\n"); else &#123; update(1,ans,ans+x-1,0,0); printf("%d,let's fly\n",ans); &#125; &#125; else if(s1[0]=='N') &#123; int x; scanf("%d",&amp;x); int ans = Find(1,x,0); //printf("DS: %d\n",ans); if(ans == 0) &#123; int res = Find(1,x,1); //printf("NS: %d\n",res); if(res == 0) &#123; printf("wait for me\n"); &#125; else &#123; update(1,res,res+x-1,0,1); update(1,res,res+x-1,0,0); printf("%d,don't put my gezi\n",res); &#125; &#125; else &#123; update(1,ans,ans+x-1,0,0); update(1,ans,ans+x-1,0,1); printf("%d,don't put my gezi\n",ans); &#125; &#125; else if(s1[0]=='S') &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); update(1,l,r,1,0); update(1,l,r,1,1); printf("I am the hope of chinese chengxuyuan!!\n"); &#125; &#125; &#125;&#125; 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道特别有想法的题]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%B8%80%E9%81%93%E7%89%B9%E5%88%AB%E6%9C%89%E6%83%B3%E6%B3%95%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意 初级：给定一段序列，序列的长度范围是1e5的，每个数的范围是正负1e9的，然后给出一个数值x，要你求这个序列里面一段连续的和且和的值为x，并且序列的长度越大越好 进阶：对于这个序列给出的数a[i]，只有0和1构成，求的是一段连续的区间里面的0和1的个数是相同的，并且长度越大越好 最终：对于这个序列给出的数可以是正负1e9的，然后求得还是一段连续的区间里面的0和1的个数是相同的，并且长度越大越好 题解 初级： 对于这个序列我们可以想到要找两个位置，i和j，i到j里面的和是x对吧，当然我们不能暴力的枚举两个位置，这样一定超时，我们可以发现可以用一个前缀和来优化求和的过程对吧，对于i到j的和不就是 sum[j]-sum[i]，sum代表前缀和，然而我们可以发现，我们需要的只是sum[i]的位置，这个位置我们也可以预处理一下，用一个map来表示前缀和这个数第一次出现的位置，这里为什么是第一次呢后面会再说。 ​ 然后对于这个序列我们先从前往后遍历不断累加一个和 sums 然后如果满足条件的话，一定有一个位置i从i到现在的sums 的位置也就是j 满足 sum[j]-sum[i] = x ，然而我们已经用map记录过 所以直接判断是不是出现过即可，出现过的话在更新一下最大长度即可 ​ 举个例子为什么是map只记录第一次的位置 比如 序列是 2 3 -3 这个时候前缀和是2 5 2 为什么只记录第一次呢，因为我们是从前往后遍历序列对吧，只记录第一次的位置这样保证长度一定是最长的！ 进阶：其实我们可以根据上面的题来想想，如果我们把所有的0都换成-1，那么问题不就变成了给定序列找一段连续的和为0，并且长度最大吗？，问题解决了 最终：其实这个思路和上面的也是一样的，我们对于别的数字我们不看，对于我们有影响的只是0和1对吧，我们就在这里面看就可以，然后还是把0改成-1，然后就可以了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define N 100005#define LL long longusing namespace std;int a[N];map&lt;long long,int&gt;m;int main()&#123; int n; LL x; while(scanf("%d%lld",&amp;n,&amp;x)==2) &#123; m.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; m[0] = -1; LL sum = 0; for(int i=1;i&lt;=n;i++) &#123; sum+=a[i]; if(m[sum]!=0) continue; else m[sum] = i; &#125; sum = 0; int len = -1; for(int i=1;i&lt;=n;i++) &#123; sum+=a[i]; if(m[sum-x]!=0) &#123; if(m[sum-x]==-1) &#123; len = max(len,i); &#125; else len = max(len,i-m[sum-x]); &#125; &#125; printf("%d\n",len); &#125;&#125; 接下来的代码和上面的都差不多 就是无非把序列的数改一改，就不在赘述]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[HDU 3308 (线段树合并 求最大连续上升序列)]]></title>
    <url>%2F2018%2F11%2F27%2FHDU-3308-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目链接 题意：​ 给定一段区间求 最长连续上升序列长度 ​ 两个操作 Q 操作区间查询最长连续上升子序列 U操作 单点更新 题解：​ 一般的区间合并问题，我算是发现了，都要维护三个基本参数 ​ 从左端开始的 从右端开始的 中间最大的 ​ 所以这个题 也不例外 维护左端开始的最长 和右端结束的最长 还有区间最长 ​ 然后 在记录一下这个区间的左右端点值 在合并的时候 需要比较 ​ 主要是如何pushup 首先往上更新的时候 最长的肯定是左右的最大的 ​ 然后 左端 判断是否贯穿 贯穿就是 左儿子右端点大于 右儿子左端点 这个时候 ​ 左端连续 要加上右儿子的左端连续 ​ 同理 右端连续也是这样 然后就可以了 ​ 然后 查找的时候 同样遵守之前的道理 你的区间要是分开的时候要判断一下 ​ 你分开的区间 左儿子的右端点和右儿子的左端点的大小比较一下 ​ 如果可以连续 我们比较一下 左右儿子的最大和 还有这个区间大小 ​ 就是你不能超过这个区间的大小和之前的找01 最长1的那个是一个道理 ​ 然后比较一个最大值就可以了 ps : 总感觉最正统的线段树往下递归的时候 都应该分三个写诶 以前两个的写法有点偷懒 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct node&#123; int l,r; int ls,rs; int lsum,rsum,sumb;&#125;;node shu[N&lt;&lt;2];int a[N];void pushup(int rt)&#123; shu[rt].ls = shu[rt&lt;&lt;1].ls; shu[rt].rs = shu[rt&lt;&lt;1|1].rs; shu[rt].sumb = max(shu[rt&lt;&lt;1].sumb,shu[rt&lt;&lt;1|1].sumb); if(shu[rt&lt;&lt;1|1].ls&gt;shu[rt&lt;&lt;1].rs) &#123; shu[rt].sumb = max(shu[rt].sumb,(shu[rt&lt;&lt;1].rsum + shu[rt&lt;&lt;1|1].lsum)); &#125; shu[rt].lsum = shu[rt&lt;&lt;1].lsum; if(shu[rt].lsum == (shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].lsum += shu[rt&lt;&lt;1|1].lsum; &#125; shu[rt].rsum = shu[rt&lt;&lt;1|1].rsum; if(shu[rt].rsum == (shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].rsum += shu[rt&lt;&lt;1].rsum; &#125;&#125;void build(int rt,int l,int r)&#123; shu[rt].l = l,shu[rt].r = r; if(l==r) &#123; shu[rt].ls = shu[rt].rs = a[l]; shu[rt].lsum = shu[rt].rsum = shu[rt].sumb = 1; return ; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid); build(rt&lt;&lt;1|1,mid+1,r); pushup(rt);&#125;void update(int rt,int pos,int val)&#123; int L = shu[rt].l ,R = shu[rt].r; if(L==R&amp;&amp;L==pos) &#123; shu[rt].ls = shu[rt].rs = val; return; &#125; int mid = (L+R)&gt;&gt;1; if(pos&lt;=mid) update(rt&lt;&lt;1,pos,val); else update(rt&lt;&lt;1|1,pos,val); pushup(rt);&#125;int Find(int rt,int l,int r)&#123; int L = shu[rt].l, R = shu[rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; return shu[rt].sumb; &#125; int ans = 0; int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) ans = max(ans,Find(rt&lt;&lt;1,l,r)); if(r&gt;mid) ans = max(ans,Find(rt&lt;&lt;1|1,l,r)); if(shu[rt&lt;&lt;1].rs &lt; shu[rt&lt;&lt;1|1].ls &amp;&amp; l&lt;=mid &amp;&amp; r&gt;mid ) &#123; ans = max(ans , (min(shu[rt&lt;&lt;1].rsum,mid-l+1)+min(shu[rt&lt;&lt;1|1].lsum,r-mid))); &#125; return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; memset(shu,0,sizeof(shu)); build(1,1,n); while(m--) &#123; char s1[10]; int l,r; scanf("%s%d%d",s1,&amp;l,&amp;r); if(s1[0]=='Q') &#123; l++,r++; int x1 = Find(1,l,r); printf("%d\n",x1); &#125; else &#123; l++; update(1,l,r); &#125; &#125; &#125;&#125; 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-线段树</tag>
      </tags>
  </entry>
</search>
