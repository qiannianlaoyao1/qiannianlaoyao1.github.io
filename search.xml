<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F11%2F29%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fmoban%2F</url>
    <content type="text"><![CDATA[题目链接 题意：​ 题解：​ AC代码1a 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[hdu 4553]]></title>
    <url>%2F2018%2F11%2F28%2Fhdu-4553%2F</url>
    <content type="text"><![CDATA[题目链接 题意：​ 题解：​ AC代码1a 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>-线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 3308 (线段树合并 求最大连续上升序列)]]></title>
    <url>%2F2018%2F11%2F27%2FHDU-3308-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目链接 题意：​ 给定一段区间求 最长连续上升序列长度 ​ 两个操作 Q 操作区间查询最长连续上升子序列 U操作 单点更新 题解：​ 一般的区间合并问题，我算是发现了，都要维护三个基本参数 ​ 从左端开始的 从右端开始的 中间最大的 ​ 所以这个题 也不例外 维护左端开始的最长 和右端结束的最长 还有区间最长 ​ 然后 在记录一下这个区间的左右端点值 在合并的时候 需要比较 ​ 主要是如何pushup 首先往上更新的时候 最长的肯定是左右的最大的 ​ 然后 左端 判断是否贯穿 贯穿就是 左儿子右端点大于 右儿子左端点 这个时候 ​ 左端连续 要加上右儿子的左端连续 ​ 同理 右端连续也是这样 然后就可以了 ​ 然后 查找的时候 同样遵守之前的道理 你的区间要是分开的时候要判断一下 ​ 你分开的区间 左儿子的右端点和右儿子的左端点的大小比较一下 ​ 如果可以连续 我们比较一下 左右儿子的最大和 还有这个区间大小 ​ 就是你不能超过这个区间的大小和之前的找01 最长1的那个是一个道理 ​ 然后比较一个最大值就可以了 ps : 总感觉最正统的线段树往下递归的时候 都应该分三个写诶 以前两个的写法有点偷懒 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct node&#123; int l,r; int ls,rs; int lsum,rsum,sumb;&#125;;node shu[N&lt;&lt;2];int a[N];void pushup(int rt)&#123; shu[rt].ls = shu[rt&lt;&lt;1].ls; shu[rt].rs = shu[rt&lt;&lt;1|1].rs; shu[rt].sumb = max(shu[rt&lt;&lt;1].sumb,shu[rt&lt;&lt;1|1].sumb); if(shu[rt&lt;&lt;1|1].ls&gt;shu[rt&lt;&lt;1].rs) &#123; shu[rt].sumb = max(shu[rt].sumb,(shu[rt&lt;&lt;1].rsum + shu[rt&lt;&lt;1|1].lsum)); &#125; shu[rt].lsum = shu[rt&lt;&lt;1].lsum; if(shu[rt].lsum == (shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].lsum += shu[rt&lt;&lt;1|1].lsum; &#125; shu[rt].rsum = shu[rt&lt;&lt;1|1].rsum; if(shu[rt].rsum == (shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].rsum += shu[rt&lt;&lt;1].rsum; &#125;&#125;void build(int rt,int l,int r)&#123; shu[rt].l = l,shu[rt].r = r; if(l==r) &#123; shu[rt].ls = shu[rt].rs = a[l]; shu[rt].lsum = shu[rt].rsum = shu[rt].sumb = 1; return ; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid); build(rt&lt;&lt;1|1,mid+1,r); pushup(rt);&#125;void update(int rt,int pos,int val)&#123; int L = shu[rt].l ,R = shu[rt].r; if(L==R&amp;&amp;L==pos) &#123; shu[rt].ls = shu[rt].rs = val; return; &#125; int mid = (L+R)&gt;&gt;1; if(pos&lt;=mid) update(rt&lt;&lt;1,pos,val); else update(rt&lt;&lt;1|1,pos,val); pushup(rt);&#125;int Find(int rt,int l,int r)&#123; int L = shu[rt].l, R = shu[rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; return shu[rt].sumb; &#125; int ans = 0; int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) ans = max(ans,Find(rt&lt;&lt;1,l,r)); if(r&gt;mid) ans = max(ans,Find(rt&lt;&lt;1|1,l,r)); if(shu[rt&lt;&lt;1].rs &lt; shu[rt&lt;&lt;1|1].ls &amp;&amp; l&lt;=mid &amp;&amp; r&gt;mid ) &#123; ans = max(ans , (min(shu[rt&lt;&lt;1].rsum,mid-l+1)+min(shu[rt&lt;&lt;1|1].lsum,r-mid))); &#125; return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; memset(shu,0,sizeof(shu)); build(1,1,n); while(m--) &#123; char s1[10]; int l,r; scanf("%s%d%d",s1,&amp;l,&amp;r); if(s1[0]=='Q') &#123; l++,r++; int x1 = Find(1,l,r); printf("%d\n",x1); &#125; else &#123; l++; update(1,l,r); &#125; &#125; &#125;&#125; 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
