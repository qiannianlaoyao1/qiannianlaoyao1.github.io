<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[哈尔滨理工大学软件与微电子学院院赛高年级组A]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%93%88%E5%B0%94%E6%BB%A8%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E4%B8%8E%E5%BE%AE%E7%94%B5%E5%AD%90%E5%AD%A6%E9%99%A2%E9%99%A2%E8%B5%9B%E9%AB%98%E5%B9%B4%E7%BA%A7%E7%BB%84A%2F</url>
    <content type="text"><![CDATA[题目链接 12345来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld 题目描述 ​ 小乐乐得知一周有7天之后就对7产生了兴趣。 ​ 小乐乐得到了两堆数字数字时连续的。 ​ 第一堆包含[1,n]n个数字，第二堆包含[1,m]m个数字。 ​ 小乐乐想要从两堆中各挑选出一个整数x,y，使得x,y的和为7的倍数。 请问小乐乐有多少种组合的方式。 输入描述:1输入整数n,m。(1&lt;=n,m&lt;=1e6) 输出描述:1输出满足的对数。 示例1 输入复制 16 7 输出复制 16 说明1(1,6),(2,5),(3,4),(4,3),(5,2),(6,1) 题解 ​ 一开始智障了，考虑７的倍数之间的关系，然后暴力打了个表，断断续续的看了半天， 也没检查有没有错误，结果表打错了，还推了半天直接gg，最后才想明白怎么处理， 举个例子，我们要是暴力的处理就是 n^2 的 第一层枚举i，第二层枚j，然后 (i+j)%7==0 对吧，然后我们在去像怎么优化，举个例子 比如 1 29 里面有 1 6 ，1 13，1 20，1 27 我们可以写一下数学公式，设x，7*x - i &lt;= m 我们可以得到这个公式，里面x代表的是 7的几倍也就是几组7的倍数，要想x得到的最大 就取等于呗，化简公式：x = (m+i)/7; 然后只需要遍历一遍1-min(n,m)，枚举i就可以了，然后还有一个注意点就是公式要变成 x = (m+i)/7 - i/7 ; 举个例子 25 26 i = 7的时候 x 按照之前的结果是 4 但是实际只有 3个 因为你把 i/7 的情况多算了 就相当于多了一个 0 7 所以 要减去i自身的情况 代码1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;int main()&#123; int n,m; while(scanf("%d%d",&amp;n,&amp;m)==2) &#123; ll sum = 0; int minx = min(n,m); int maxn = max(n,m); for(int i=1;i&lt;=minx;i++) &#123; sum+=((maxn+i)/7-i/7); //printf("%d %d\n",i,((maxn+i)/7-i/7)); &#125; printf("%lld\n",sum); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 4553 线段树区间合并]]></title>
    <url>%2F2018%2F11%2F30%2FHDU-4553-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目链接 题意：​ 有女神和屌丝两种朋友，屌丝每次申请x时间，女神每次也申请x时间，每次都找最靠左的时间 然后女神优先级高于屌丝，可以覆盖屌丝的时间，但是，如果屌丝被覆盖的不完全，比如 1-5 是屌丝 然后女神占了1-3，剩下的4-5 还是屌丝的。 题解：​ 正常的线段树区间01维护，然后开两个树，一个维护屌丝的时间，一个维护女神的时间 屌丝就正常在屌丝的树上，维护 更新 ，然后女神的话，现在屌丝树上看 有没有地方 有地方就 更新屌丝树，然后如果没有地方的话 ，在女神树上找一段时间 找到了 在女神树和屌丝树都更新 一下因为有可能女神占用屌丝的时间 ，比之前的屌丝时间还多，所以需要更新一下。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 100010struct node&#123; int l,r; int ls,rs,sum; int lazy;&#125;;node shu[2][N&lt;&lt;2];void pushup(int rt,int inx)&#123; shu[inx][rt].ls = shu[inx][rt&lt;&lt;1].ls; shu[inx][rt].rs = shu[inx][rt&lt;&lt;1|1].rs; if(shu[inx][rt&lt;&lt;1].ls==(shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].l + 1)) &#123; shu[inx][rt].ls += shu[inx][rt&lt;&lt;1|1].ls; &#125; if(shu[inx][rt&lt;&lt;1|1].rs==(shu[inx][rt&lt;&lt;1|1].r - shu[inx][rt&lt;&lt;1|1].l + 1)) &#123; shu[inx][rt].rs += shu[inx][rt&lt;&lt;1].rs; &#125; shu[inx][rt].sum = max(max(shu[inx][rt&lt;&lt;1].sum,shu[inx][rt&lt;&lt;1|1].sum),shu[inx][rt&lt;&lt;1].rs+shu[inx][rt&lt;&lt;1|1].ls);&#125;void pushdown(int rt,int inx)&#123; if(shu[inx][rt].lazy == 1) &#123; shu[inx][rt&lt;&lt;1].ls = shu[inx][rt&lt;&lt;1].rs = shu[inx][rt&lt;&lt;1].sum = (shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].l + 1); shu[inx][rt&lt;&lt;1|1].ls = shu[inx][rt&lt;&lt;1|1].rs = shu[inx][rt&lt;&lt;1|1].sum = (shu[inx][rt&lt;&lt;1|1].r - shu[inx][rt&lt;&lt;1|1].l + 1); shu[inx][rt&lt;&lt;1].lazy = shu[inx][rt].lazy; shu[inx][rt&lt;&lt;1|1].lazy = shu[inx][rt].lazy; shu[inx][rt].lazy = 0; &#125; else if(shu[inx][rt].lazy == 2) &#123; shu[inx][rt&lt;&lt;1].ls = shu[inx][rt&lt;&lt;1].rs = shu[inx][rt&lt;&lt;1].sum = 0; shu[inx][rt&lt;&lt;1|1].ls = shu[inx][rt&lt;&lt;1|1].rs = shu[inx][rt&lt;&lt;1|1].sum = 0; shu[inx][rt&lt;&lt;1].lazy = shu[inx][rt].lazy; shu[inx][rt&lt;&lt;1|1].lazy = shu[inx][rt].lazy; shu[inx][rt].lazy = 0; &#125;&#125;void build(int rt,int l,int r,int inx)&#123; shu[inx][rt].l = l,shu[inx][rt].r = r; shu[inx][rt].lazy = 0; if(l==r) &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = 1; return; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid,inx); build(rt&lt;&lt;1|1,mid+1,r,inx); pushup(rt,inx);&#125;void update(int rt,int l,int r,int val,int inx)&#123; int L = shu[inx][rt].l , R = shu[inx][rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; if(val) &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = R-L+1; shu[inx][rt].lazy = 1; &#125; else &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = 0; shu[inx][rt].lazy = 2; &#125; &#125; else &#123; pushdown(rt,inx); int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) update(rt&lt;&lt;1,l,r,val,inx); if(mid&lt;r) update(rt&lt;&lt;1|1,l,r,val,inx); pushup(rt,inx); &#125;&#125;int Find(int rt,int val,int inx)&#123; if(shu[inx][rt].ls == val) return shu[inx][rt].l; //当前区间最左边可以吗 if(shu[inx][rt].sum&gt;=val) //当前区间可以吗 &#123; pushdown(rt,inx); //下传 if(shu[inx][rt&lt;&lt;1].sum&gt;=val) return Find(rt&lt;&lt;1,val,inx); //当前区间左儿子可以吗 if(shu[inx][rt&lt;&lt;1].rs+shu[inx][rt&lt;&lt;1|1].ls &gt;=val) return shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].rs+1; // 当前区间分开的中间可以吗 if(shu[inx][rt&lt;&lt;1|1].sum&gt;=val) return Find(rt&lt;&lt;1|1,val,inx); // 当前区间右儿子可以吗 &#125; return 0;&#125;int main()&#123; int t; scanf("%d",&amp;t); int kk = 1; while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); memset(shu,0,sizeof(shu)); build(1,1,n,0); // 0代表ds树 build(1,1,n,1); // 1代表ns树 printf("Case %d:\n",kk++); char s1[10]; for(int i=0; i&lt;m; i++) &#123; scanf("%s",s1); if(s1[0]=='D') &#123; int x; scanf("%d",&amp;x); int ans = Find(1,x,0); if(ans == 0 ) printf("fly with yourself\n"); else &#123; update(1,ans,ans+x-1,0,0); printf("%d,let's fly\n",ans); &#125; &#125; else if(s1[0]=='N') &#123; int x; scanf("%d",&amp;x); int ans = Find(1,x,0); //printf("DS: %d\n",ans); if(ans == 0) &#123; int res = Find(1,x,1); //printf("NS: %d\n",res); if(res == 0) &#123; printf("wait for me\n"); &#125; else &#123; update(1,res,res+x-1,0,1); update(1,res,res+x-1,0,0); printf("%d,don't put my gezi\n",res); &#125; &#125; else &#123; update(1,ans,ans+x-1,0,0); update(1,ans,ans+x-1,0,1); printf("%d,don't put my gezi\n",ans); &#125; &#125; else if(s1[0]=='S') &#123; int l,r; scanf("%d%d",&amp;l,&amp;r); update(1,l,r,1,0); update(1,l,r,1,1); printf("I am the hope of chinese chengxuyuan!!\n"); &#125; &#125; &#125;&#125; 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道特别有想法的题]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%B8%80%E9%81%93%E7%89%B9%E5%88%AB%E6%9C%89%E6%83%B3%E6%B3%95%E7%9A%84%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意 初级：给定一段序列，序列的长度范围是1e5的，每个数的范围是正负1e9的，然后给出一个数值x，要你求这个序列里面一段连续的和且和的值为x，并且序列的长度越大越好 进阶：对于这个序列给出的数a[i]，只有0和1构成，求的是一段连续的区间里面的0和1的个数是相同的，并且长度越大越好 最终：对于这个序列给出的数可以是正负1e9的，然后求得还是一段连续的区间里面的0和1的个数是相同的，并且长度越大越好 题解 初级： 对于这个序列我们可以想到要找两个位置，i和j，i到j里面的和是x对吧，当然我们不能暴力的枚举两个位置，这样一定超时，我们可以发现可以用一个前缀和来优化求和的过程对吧，对于i到j的和不就是 sum[j]-sum[i]，sum代表前缀和，然而我们可以发现，我们需要的只是sum[i]的位置，这个位置我们也可以预处理一下，用一个map来表示前缀和这个数第一次出现的位置，这里为什么是第一次呢后面会再说。 ​ 然后对于这个序列我们先从前往后遍历不断累加一个和 sums 然后如果满足条件的话，一定有一个位置i从i到现在的sums 的位置也就是j 满足 sum[j]-sum[i] = x ，然而我们已经用map记录过 所以直接判断是不是出现过即可，出现过的话在更新一下最大长度即可 ​ 举个例子为什么是map只记录第一次的位置 比如 序列是 2 3 -3 这个时候前缀和是2 5 2 为什么只记录第一次呢，因为我们是从前往后遍历序列对吧，只记录第一次的位置这样保证长度一定是最长的！ 进阶：其实我们可以根据上面的题来想想，如果我们把所有的0都换成-1，那么问题不就变成了给定序列找一段连续的和为0，并且长度最大吗？，问题解决了 最终：其实这个思路和上面的也是一样的，我们对于别的数字我们不看，对于我们有影响的只是0和1对吧，我们就在这里面看就可以，然后还是把0改成-1，然后就可以了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define N 100005#define LL long longusing namespace std;int a[N];map&lt;long long,int&gt;m;int main()&#123; int n; LL x; while(scanf("%d%lld",&amp;n,&amp;x)==2) &#123; m.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; m[0] = -1; LL sum = 0; for(int i=1;i&lt;=n;i++) &#123; sum+=a[i]; if(m[sum]!=0) continue; else m[sum] = i; &#125; sum = 0; int len = -1; for(int i=1;i&lt;=n;i++) &#123; sum+=a[i]; if(m[sum-x]!=0) &#123; if(m[sum-x]==-1) &#123; len = max(len,i); &#125; else len = max(len,i-m[sum-x]); &#125; &#125; printf("%d\n",len); &#125;&#125; 接下来的代码和上面的都差不多 就是无非把序列的数改一改，就不在赘述]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[HDU 3308 (线段树合并 求最大连续上升序列)]]></title>
    <url>%2F2018%2F11%2F27%2FHDU-3308-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6-%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目链接 题意：​ 给定一段区间求 最长连续上升序列长度 ​ 两个操作 Q 操作区间查询最长连续上升子序列 U操作 单点更新 题解：​ 一般的区间合并问题，我算是发现了，都要维护三个基本参数 ​ 从左端开始的 从右端开始的 中间最大的 ​ 所以这个题 也不例外 维护左端开始的最长 和右端结束的最长 还有区间最长 ​ 然后 在记录一下这个区间的左右端点值 在合并的时候 需要比较 ​ 主要是如何pushup 首先往上更新的时候 最长的肯定是左右的最大的 ​ 然后 左端 判断是否贯穿 贯穿就是 左儿子右端点大于 右儿子左端点 这个时候 ​ 左端连续 要加上右儿子的左端连续 ​ 同理 右端连续也是这样 然后就可以了 ​ 然后 查找的时候 同样遵守之前的道理 你的区间要是分开的时候要判断一下 ​ 你分开的区间 左儿子的右端点和右儿子的左端点的大小比较一下 ​ 如果可以连续 我们比较一下 左右儿子的最大和 还有这个区间大小 ​ 就是你不能超过这个区间的大小和之前的找01 最长1的那个是一个道理 ​ 然后比较一个最大值就可以了 ps : 总感觉最正统的线段树往下递归的时候 都应该分三个写诶 以前两个的写法有点偷懒 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct node&#123; int l,r; int ls,rs; int lsum,rsum,sumb;&#125;;node shu[N&lt;&lt;2];int a[N];void pushup(int rt)&#123; shu[rt].ls = shu[rt&lt;&lt;1].ls; shu[rt].rs = shu[rt&lt;&lt;1|1].rs; shu[rt].sumb = max(shu[rt&lt;&lt;1].sumb,shu[rt&lt;&lt;1|1].sumb); if(shu[rt&lt;&lt;1|1].ls&gt;shu[rt&lt;&lt;1].rs) &#123; shu[rt].sumb = max(shu[rt].sumb,(shu[rt&lt;&lt;1].rsum + shu[rt&lt;&lt;1|1].lsum)); &#125; shu[rt].lsum = shu[rt&lt;&lt;1].lsum; if(shu[rt].lsum == (shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].lsum += shu[rt&lt;&lt;1|1].lsum; &#125; shu[rt].rsum = shu[rt&lt;&lt;1|1].rsum; if(shu[rt].rsum == (shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].rsum += shu[rt&lt;&lt;1].rsum; &#125;&#125;void build(int rt,int l,int r)&#123; shu[rt].l = l,shu[rt].r = r; if(l==r) &#123; shu[rt].ls = shu[rt].rs = a[l]; shu[rt].lsum = shu[rt].rsum = shu[rt].sumb = 1; return ; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid); build(rt&lt;&lt;1|1,mid+1,r); pushup(rt);&#125;void update(int rt,int pos,int val)&#123; int L = shu[rt].l ,R = shu[rt].r; if(L==R&amp;&amp;L==pos) &#123; shu[rt].ls = shu[rt].rs = val; return; &#125; int mid = (L+R)&gt;&gt;1; if(pos&lt;=mid) update(rt&lt;&lt;1,pos,val); else update(rt&lt;&lt;1|1,pos,val); pushup(rt);&#125;int Find(int rt,int l,int r)&#123; int L = shu[rt].l, R = shu[rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; return shu[rt].sumb; &#125; int ans = 0; int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) ans = max(ans,Find(rt&lt;&lt;1,l,r)); if(r&gt;mid) ans = max(ans,Find(rt&lt;&lt;1|1,l,r)); if(shu[rt&lt;&lt;1].rs &lt; shu[rt&lt;&lt;1|1].ls &amp;&amp; l&lt;=mid &amp;&amp; r&gt;mid ) &#123; ans = max(ans , (min(shu[rt&lt;&lt;1].rsum,mid-l+1)+min(shu[rt&lt;&lt;1|1].lsum,r-mid))); &#125; return ans;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; memset(shu,0,sizeof(shu)); build(1,1,n); while(m--) &#123; char s1[10]; int l,r; scanf("%s%d%d",s1,&amp;l,&amp;r); if(s1[0]=='Q') &#123; l++,r++; int x1 = Find(1,l,r); printf("%d\n",x1); &#125; else &#123; l++; update(1,l,r); &#125; &#125; &#125;&#125; 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
