{"meta":{"title":"qiannianlaoyao's Blog","subtitle":null,"description":"今番良晤，豪兴不浅！","author":"王浩东","url":"http://www.qnlywhd.top"},"pages":[{"title":"about","date":"2018-11-27T12:32:30.000Z","updated":"2018-11-27T12:53:50.308Z","comments":true,"path":"about/index.html","permalink":"http://www.qnlywhd.top/about/index.html","excerpt":"","text":"关于我​ 哈尔滨理工大学 软件工程专业的一名学生 ，在大学期间打过acm 虽然成绩一般 ​ 只有获得过 2018 icpc 北京站 铜奖 ​ 但是有一颗热爱编程的心 平时的爱好 是运动和看动漫 关于博客​ 以前的时候 被推荐过作博客 可是自己太懒了 一直都是在记笔记 现在的话 更多的想 ​ 要分享一些学到的知识和生活经历 联系我​ QQ: 1695522428 ​ Github: 这里-&gt; ​ CSDN: 这里-&gt;"},{"title":"分类","date":"2018-11-30T12:08:11.000Z","updated":"2018-11-30T12:54:30.731Z","comments":true,"path":"categories/index.html","permalink":"http://www.qnlywhd.top/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-11-27T12:51:14.000Z","updated":"2018-11-27T13:12:31.774Z","comments":true,"path":"friends/index.html","permalink":"http://www.qnlywhd.top/friends/index.html","excerpt":"","text":"宋增林老哥 (阿里大佬) ：神奇的传送门 张禹欧巴 ：神奇的传送门 mengxiang000000 ：神奇的传送门 全哥 ：神奇的传送门 尚神 ：神奇的传送门 老贾 ：神奇的传送门 zcy (沙雕室友兼大腿队友) ：神奇的传送门 思远 ：神奇的传送门"},{"title":"标签","date":"2018-11-30T12:07:58.000Z","updated":"2018-11-30T12:39:17.441Z","comments":true,"path":"tags/index.html","permalink":"http://www.qnlywhd.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HDU 4553 线段树区间合并","slug":"HDU-4553-线段树区间合并","date":"2018-11-30T13:58:19.000Z","updated":"2018-12-04T07:46:33.338Z","comments":true,"path":"2018/11/30/HDU-4553-线段树区间合并/","link":"","permalink":"http://www.qnlywhd.top/2018/11/30/HDU-4553-线段树区间合并/","excerpt":"","text":"题目链接 题意：​ 有女神和屌丝两种朋友，屌丝每次申请x时间，女神每次也申请x时间，每次都找最靠左的时间 然后女神优先级高于屌丝，可以覆盖屌丝的时间，但是，如果屌丝被覆盖的不完全，比如 1-5 是屌丝 然后女神占了1-3，剩下的4-5 还是屌丝的。 题解：​ 正常的线段树区间01维护，然后开两个树，一个维护屌丝的时间，一个维护女神的时间 屌丝就正常在屌丝的树上，维护 更新 ，然后女神的话，现在屌丝树上看 有没有地方 有地方就 更新屌丝树，然后如果没有地方的话 ，在女神树上找一段时间 找到了 在女神树和屌丝树都更新 一下因为有可能女神占用屌丝的时间 ，比之前的屌丝时间还多，所以需要更新一下。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 100010struct node&#123; int l,r; int ls,rs,sum; int lazy;&#125;;node shu[2][N&lt;&lt;2];void pushup(int rt,int inx)&#123; shu[inx][rt].ls = shu[inx][rt&lt;&lt;1].ls; shu[inx][rt].rs = shu[inx][rt&lt;&lt;1|1].rs; if(shu[inx][rt&lt;&lt;1].ls==(shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].l + 1)) &#123; shu[inx][rt].ls += shu[inx][rt&lt;&lt;1|1].ls; &#125; if(shu[inx][rt&lt;&lt;1|1].rs==(shu[inx][rt&lt;&lt;1|1].r - shu[inx][rt&lt;&lt;1|1].l + 1)) &#123; shu[inx][rt].rs += shu[inx][rt&lt;&lt;1].rs; &#125; shu[inx][rt].sum = max(max(shu[inx][rt&lt;&lt;1].sum,shu[inx][rt&lt;&lt;1|1].sum),shu[inx][rt&lt;&lt;1].rs+shu[inx][rt&lt;&lt;1|1].ls);&#125;void pushdown(int rt,int inx)&#123; if(shu[inx][rt].lazy == 1) &#123; shu[inx][rt&lt;&lt;1].ls = shu[inx][rt&lt;&lt;1].rs = shu[inx][rt&lt;&lt;1].sum = (shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].l + 1); shu[inx][rt&lt;&lt;1|1].ls = shu[inx][rt&lt;&lt;1|1].rs = shu[inx][rt&lt;&lt;1|1].sum = (shu[inx][rt&lt;&lt;1|1].r - shu[inx][rt&lt;&lt;1|1].l + 1); shu[inx][rt&lt;&lt;1].lazy = shu[inx][rt].lazy; shu[inx][rt&lt;&lt;1|1].lazy = shu[inx][rt].lazy; shu[inx][rt].lazy = 0; &#125; else if(shu[inx][rt].lazy == 2) &#123; shu[inx][rt&lt;&lt;1].ls = shu[inx][rt&lt;&lt;1].rs = shu[inx][rt&lt;&lt;1].sum = 0; shu[inx][rt&lt;&lt;1|1].ls = shu[inx][rt&lt;&lt;1|1].rs = shu[inx][rt&lt;&lt;1|1].sum = 0; shu[inx][rt&lt;&lt;1].lazy = shu[inx][rt].lazy; shu[inx][rt&lt;&lt;1|1].lazy = shu[inx][rt].lazy; shu[inx][rt].lazy = 0; &#125;&#125;void build(int rt,int l,int r,int inx)&#123; shu[inx][rt].l = l,shu[inx][rt].r = r; shu[inx][rt].lazy = 0; if(l==r) &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = 1; return; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid,inx); build(rt&lt;&lt;1|1,mid+1,r,inx); pushup(rt,inx);&#125;void update(int rt,int l,int r,int val,int inx)&#123; int L = shu[inx][rt].l , R = shu[inx][rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; if(val) &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = R-L+1; shu[inx][rt].lazy = 1; &#125; else &#123; shu[inx][rt].ls = shu[inx][rt].rs = shu[inx][rt].sum = 0; shu[inx][rt].lazy = 2; &#125; &#125; else &#123; pushdown(rt,inx); int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) update(rt&lt;&lt;1,l,r,val,inx); if(mid&lt;r) update(rt&lt;&lt;1|1,l,r,val,inx); pushup(rt,inx); &#125;&#125;int Find(int rt,int val,int inx)&#123; if(shu[inx][rt].ls == val) return shu[inx][rt].l; //当前区间最左边可以吗 if(shu[inx][rt].sum&gt;=val) //当前区间可以吗 &#123; pushdown(rt,inx); //下传 if(shu[inx][rt&lt;&lt;1].sum&gt;=val) return Find(rt&lt;&lt;1,val,inx); //当前区间左儿子可以吗 if(shu[inx][rt&lt;&lt;1].rs+shu[inx][rt&lt;&lt;1|1].ls &gt;=val) return shu[inx][rt&lt;&lt;1].r - shu[inx][rt&lt;&lt;1].rs+1; // 当前区间分开的中间可以吗 if(shu[inx][rt&lt;&lt;1|1].sum&gt;=val) return Find(rt&lt;&lt;1|1,val,inx); // 当前区间右儿子可以吗 &#125; return 0;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); int kk = 1; while(t--) &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); memset(shu,0,sizeof(shu)); build(1,1,n,0); // 0代表ds树 build(1,1,n,1); // 1代表ns树 printf(\"Case %d:\\n\",kk++); char s1[10]; for(int i=0; i&lt;m; i++) &#123; scanf(\"%s\",s1); if(s1[0]=='D') &#123; int x; scanf(\"%d\",&amp;x); int ans = Find(1,x,0); if(ans == 0 ) printf(\"fly with yourself\\n\"); else &#123; update(1,ans,ans+x-1,0,0); printf(\"%d,let's fly\\n\",ans); &#125; &#125; else if(s1[0]=='N') &#123; int x; scanf(\"%d\",&amp;x); int ans = Find(1,x,0); //printf(\"DS: %d\\n\",ans); if(ans == 0) &#123; int res = Find(1,x,1); //printf(\"NS: %d\\n\",res); if(res == 0) &#123; printf(\"wait for me\\n\"); &#125; else &#123; update(1,res,res+x-1,0,1); update(1,res,res+x-1,0,0); printf(\"%d,don't put my gezi\\n\",res); &#125; &#125; else &#123; update(1,ans,ans+x-1,0,0); update(1,ans,ans+x-1,0,1); printf(\"%d,don't put my gezi\\n\",ans); &#125; &#125; else if(s1[0]=='S') &#123; int l,r; scanf(\"%d%d\",&amp;l,&amp;r); update(1,l,r,1,0); update(1,l,r,1,1); printf(\"I am the hope of chinese chengxuyuan!!\\n\"); &#125; &#125; &#125;&#125; 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://www.qnlywhd.top/categories/ACM/"}],"tags":[]},{"title":"一道特别有想法的题","slug":"一道特别有想法的题","date":"2018-11-30T13:00:16.000Z","updated":"2018-11-30T13:54:53.655Z","comments":true,"path":"2018/11/30/一道特别有想法的题/","link":"","permalink":"http://www.qnlywhd.top/2018/11/30/一道特别有想法的题/","excerpt":"","text":"题意 初级：给定一段序列，序列的长度范围是1e5的，每个数的范围是正负1e9的，然后给出一个数值x，要你求这个序列里面一段连续的和且和的值为x，并且序列的长度越大越好 进阶：对于这个序列给出的数a[i]，只有0和1构成，求的是一段连续的区间里面的0和1的个数是相同的，并且长度越大越好 最终：对于这个序列给出的数可以是正负1e9的，然后求得还是一段连续的区间里面的0和1的个数是相同的，并且长度越大越好 题解 初级： 对于这个序列我们可以想到要找两个位置，i和j，i到j里面的和是x对吧，当然我们不能暴力的枚举两个位置，这样一定超时，我们可以发现可以用一个前缀和来优化求和的过程对吧，对于i到j的和不就是 sum[j]-sum[i]，sum代表前缀和，然而我们可以发现，我们需要的只是sum[i]的位置，这个位置我们也可以预处理一下，用一个map来表示前缀和这个数第一次出现的位置，这里为什么是第一次呢后面会再说。 ​ 然后对于这个序列我们先从前往后遍历不断累加一个和 sums 然后如果满足条件的话，一定有一个位置i从i到现在的sums 的位置也就是j 满足 sum[j]-sum[i] = x ，然而我们已经用map记录过 所以直接判断是不是出现过即可，出现过的话在更新一下最大长度即可 ​ 举个例子为什么是map只记录第一次的位置 比如 序列是 2 3 -3 这个时候前缀和是2 5 2 为什么只记录第一次呢，因为我们是从前往后遍历序列对吧，只记录第一次的位置这样保证长度一定是最长的！ 进阶：其实我们可以根据上面的题来想想，如果我们把所有的0都换成-1，那么问题不就变成了给定序列找一段连续的和为0，并且长度最大吗？，问题解决了 最终：其实这个思路和上面的也是一样的，我们对于别的数字我们不看，对于我们有影响的只是0和1对吧，我们就在这里面看就可以，然后还是把0改成-1，然后就可以了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define N 100005#define LL long longusing namespace std;int a[N];map&lt;long long,int&gt;m;int main()&#123; int n; LL x; while(scanf(\"%d%lld\",&amp;n,&amp;x)==2) &#123; m.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; m[0] = -1; LL sum = 0; for(int i=1;i&lt;=n;i++) &#123; sum+=a[i]; if(m[sum]!=0) continue; else m[sum] = i; &#125; sum = 0; int len = -1; for(int i=1;i&lt;=n;i++) &#123; sum+=a[i]; if(m[sum-x]!=0) &#123; if(m[sum-x]==-1) &#123; len = max(len,i); &#125; else len = max(len,i-m[sum-x]); &#125; &#125; printf(\"%d\\n\",len); &#125;&#125; 接下来的代码和上面的都差不多 就是无非把序列的数改一改，就不在赘述","categories":[{"name":"ACM","slug":"ACM","permalink":"http://www.qnlywhd.top/categories/ACM/"}],"tags":[{"name":"思维","slug":"思维","permalink":"http://www.qnlywhd.top/tags/思维/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-28T11:23:22.782Z","updated":"2018-11-28T11:23:22.782Z","comments":true,"path":"2018/11/28/hello-world/","link":"","permalink":"http://www.qnlywhd.top/2018/11/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"hdu 4553","slug":"hdu-4553","date":"2018-11-28T11:20:24.000Z","updated":"2018-11-28T13:59:09.359Z","comments":true,"path":"2018/11/28/hdu-4553/","link":"","permalink":"http://www.qnlywhd.top/2018/11/28/hdu-4553/","excerpt":"","text":"题目链接 题意：​ 题解：​ AC代码1a 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://www.qnlywhd.top/categories/ACM/"}],"tags":[{"name":"-线段树","slug":"线段树","permalink":"http://www.qnlywhd.top/tags/线段树/"}]},{"title":"HDU 3308 (线段树合并 求最大连续上升序列)","slug":"HDU-3308-线段树合并-求最大连续子串","date":"2018-11-27T14:00:31.000Z","updated":"2018-11-28T11:06:37.446Z","comments":true,"path":"2018/11/27/HDU-3308-线段树合并-求最大连续子串/","link":"","permalink":"http://www.qnlywhd.top/2018/11/27/HDU-3308-线段树合并-求最大连续子串/","excerpt":"","text":"题目链接 题意：​ 给定一段区间求 最长连续上升序列长度 ​ 两个操作 Q 操作区间查询最长连续上升子序列 U操作 单点更新 题解：​ 一般的区间合并问题，我算是发现了，都要维护三个基本参数 ​ 从左端开始的 从右端开始的 中间最大的 ​ 所以这个题 也不例外 维护左端开始的最长 和右端结束的最长 还有区间最长 ​ 然后 在记录一下这个区间的左右端点值 在合并的时候 需要比较 ​ 主要是如何pushup 首先往上更新的时候 最长的肯定是左右的最大的 ​ 然后 左端 判断是否贯穿 贯穿就是 左儿子右端点大于 右儿子左端点 这个时候 ​ 左端连续 要加上右儿子的左端连续 ​ 同理 右端连续也是这样 然后就可以了 ​ 然后 查找的时候 同样遵守之前的道理 你的区间要是分开的时候要判断一下 ​ 你分开的区间 左儿子的右端点和右儿子的左端点的大小比较一下 ​ 如果可以连续 我们比较一下 左右儿子的最大和 还有这个区间大小 ​ 就是你不能超过这个区间的大小和之前的找01 最长1的那个是一个道理 ​ 然后比较一个最大值就可以了 ps : 总感觉最正统的线段树往下递归的时候 都应该分三个写诶 以前两个的写法有点偷懒 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define N 100005using namespace std;struct node&#123; int l,r; int ls,rs; int lsum,rsum,sumb;&#125;;node shu[N&lt;&lt;2];int a[N];void pushup(int rt)&#123; shu[rt].ls = shu[rt&lt;&lt;1].ls; shu[rt].rs = shu[rt&lt;&lt;1|1].rs; shu[rt].sumb = max(shu[rt&lt;&lt;1].sumb,shu[rt&lt;&lt;1|1].sumb); if(shu[rt&lt;&lt;1|1].ls&gt;shu[rt&lt;&lt;1].rs) &#123; shu[rt].sumb = max(shu[rt].sumb,(shu[rt&lt;&lt;1].rsum + shu[rt&lt;&lt;1|1].lsum)); &#125; shu[rt].lsum = shu[rt&lt;&lt;1].lsum; if(shu[rt].lsum == (shu[rt&lt;&lt;1].r - shu[rt&lt;&lt;1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].lsum += shu[rt&lt;&lt;1|1].lsum; &#125; shu[rt].rsum = shu[rt&lt;&lt;1|1].rsum; if(shu[rt].rsum == (shu[rt&lt;&lt;1|1].r - shu[rt&lt;&lt;1|1].l+1) &amp;&amp; shu[rt&lt;&lt;1].rs&lt;shu[rt&lt;&lt;1|1].ls) &#123; shu[rt].rsum += shu[rt&lt;&lt;1].rsum; &#125;&#125;void build(int rt,int l,int r)&#123; shu[rt].l = l,shu[rt].r = r; if(l==r) &#123; shu[rt].ls = shu[rt].rs = a[l]; shu[rt].lsum = shu[rt].rsum = shu[rt].sumb = 1; return ; &#125; int mid = (l+r)&gt;&gt;1; build(rt&lt;&lt;1,l,mid); build(rt&lt;&lt;1|1,mid+1,r); pushup(rt);&#125;void update(int rt,int pos,int val)&#123; int L = shu[rt].l ,R = shu[rt].r; if(L==R&amp;&amp;L==pos) &#123; shu[rt].ls = shu[rt].rs = val; return; &#125; int mid = (L+R)&gt;&gt;1; if(pos&lt;=mid) update(rt&lt;&lt;1,pos,val); else update(rt&lt;&lt;1|1,pos,val); pushup(rt);&#125;int Find(int rt,int l,int r)&#123; int L = shu[rt].l, R = shu[rt].r; if(l&lt;=L&amp;&amp;R&lt;=r) &#123; return shu[rt].sumb; &#125; int ans = 0; int mid = (L+R)&gt;&gt;1; if(l&lt;=mid) ans = max(ans,Find(rt&lt;&lt;1,l,r)); if(r&gt;mid) ans = max(ans,Find(rt&lt;&lt;1|1,l,r)); if(shu[rt&lt;&lt;1].rs &lt; shu[rt&lt;&lt;1|1].ls &amp;&amp; l&lt;=mid &amp;&amp; r&gt;mid ) &#123; ans = max(ans , (min(shu[rt&lt;&lt;1].rsum,mid-l+1)+min(shu[rt&lt;&lt;1|1].lsum,r-mid))); &#125; return ans;&#125;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--) &#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;a[i]); &#125; memset(shu,0,sizeof(shu)); build(1,1,n); while(m--) &#123; char s1[10]; int l,r; scanf(\"%s%d%d\",s1,&amp;l,&amp;r); if(s1[0]=='Q') &#123; l++,r++; int x1 = Find(1,l,r); printf(\"%d\\n\",x1); &#125; else &#123; l++; update(1,l,r); &#125; &#125; &#125;&#125; 作者拥有版权，请注明出处转载！ 如果觉得有什么疑惑或者博主代码有什么问题，可以通过关于我，加我QQ联系 ，感谢。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://www.qnlywhd.top/categories/ACM/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://www.qnlywhd.top/tags/线段树/"}]}]}